class Piece
/*
class responsible for the variables and operations of all the subclasses(types of pieces in the game)
*/
types
	public Color = <Blue> | <Red>; -- Defines the player to whom that piece belong
values
-- Correspond to global variables such as PI
instance variables
	public color: Color;
	public value: nat1;
	
operations --Correspond to operations in UML, methods in Java, and memberfunctions in C++ 
	protected Piece : Color * nat1 ==> Piece
	Piece(a_color, a_value) ==(
		color := a_color;
		value := a_value;
		return self;
	);
	
	--returns the color of the piece
	public getColor : () ==> Color
	getColor() ==(
		return self.color;
	);
	
	--returns the color of the piece
	public getValue : () ==> nat1
	getValue() ==(
		return self.value;
	);
		
	--checks if a piece in a certain tile can move to another one
	public canMoveTo : Tile * Tile  ==> bool
	canMoveTo(ti, tf) 
		== is subclass responsibility;
		
	public isAllRiverH: Tile * Tile ==> bool
	isAllRiverH(ti, tf) == (

			if((ti.getCoordinates()(2) = tf.getCoordinates()(2)) = false)
				then return false
			else(
			
				dcl tempx: nat1 := ti.getCoordinates()(1) + 1;		
				
				while (tempx < tf.getCoordinates()(1)) do(
					dcl tempT: Tile := new Tile([tempx, ti.getCoordinates()(2)]);
					if(tempT.isRiver() = false or is_Rat(tempT.getPiece()))
						then return false
					else
						tempx := tempx + 1;
					);
					
				return true;
						
				)
	);
	
	public isAllRiverV: Tile * Tile ==> bool
	isAllRiverV(ti, tf) == (
	
			if((ti.getCoordinates()(1) = tf.getCoordinates()(1)) = false)
				then return false
			else(
			
				dcl tempy: nat1 := ti.getCoordinates()(2) + 1;		
				
				while (tempy < tf.getCoordinates()(1)) do(
					dcl tempT: Tile := new Tile([ti.getCoordinates()(1), tempy]);
					if(tempT.isRiver() = false or is_Rat(tempT.getPiece()))
						then return false
					else
						tempy := tempy + 1;
					);
					
				return true;
						
				)
				
	);

end Piece